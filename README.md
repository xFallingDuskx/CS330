# Exam Preparation Schedule

Based on the time you have available, here's a suggested schedule for reviewing the material:

Friday, April 28:
- 9am-12pm: Review materials on Divide-and-Conquer Algorithms, Graph Traversal and Shortest Paths, and Dynamic Programming.

Sunday, April 30:
- 11am-3pm: Review materials on Maximum-Flow/Min-Cut and Matching and Linear Programming.

Monday, May 1:
- 9am-11am: Attend review session on Divide-and-Conquer Algorithms, Graph Traversal and Shortest Paths, and Dynamic Programming.
- 1pm-3pm: Review materials on NP-Completeness and Hashing/Sketches.
- 4pm-6pm: Review materials on Maximum-Flow/Min-Cut and Matching and Linear Programming.

Tuesday, May 2:
- 11am-1pm: Attend review session on Maximum-Flow/Min-Cut and Matching and Linear Programming.
- 2pm-4pm: Attend review session on NP-Completeness and Hashing/Sketches.

Wednesday, May 3:
- Exam day! Give yourself time to review and prepare before the exam.

# Review Sheet for Algorithms Final Exam

## 1. Divide-and-Conquer Algorithms

Divide-and-conquer algorithms are algorithms that break down a problem into smaller subproblems, solve each subproblem independently, and combine the solutions to form a solution to the original problem.

Examples:
- Merge sort
- Quick sort

Resources:
- [GeeksforGeeks: Divide and Conquer Algorithms](https://www.geeksforgeeks.org/divide-and-conquer-algorithm-introduction/)
- [Khan Academy: Divide and Conquer Algorithms](https://www.khanacademy.org/computing/computer-science/algorithms/merge-sort/a/divide-and-conquer-algorithms)

## 2. Graph Traversal and Shortest Paths

Graph traversal algorithms are algorithms that visit all the vertices and edges of a graph in a systematic way. Shortest path algorithms are algorithms that find the shortest path between two vertices in a graph.

Examples:
- Breadth-first search (BFS)
- Depth-first search (DFS)
- Dijkstra's algorithm
- Bellman-Ford algorithm
- Floyd-Warshall algorithm

Resources:
- [GeeksforGeeks: Graph Traversal Techniques](https://www.geeksforgeeks.org/graph-traversal-techniques/)
- [Khan Academy: Graph Algorithms](https://www.khanacademy.org/computing/computer-science/algorithms/graph-representation/a/representing-graphs)
- [Brilliant: Shortest Paths in Graphs](https://brilliant.org/wiki/shortest-paths-in-graphs/)

## 3. Dynamic Programming

Dynamic programming is a technique for solving optimization problems by breaking them down into smaller subproblems and solving each subproblem only once.

Examples:
- Knapsack problem
- Longest common subsequence problem
- Edit distance problem

Resources:
- [GeeksforGeeks: Dynamic Programming](https://www.geeksforgeeks.org/dynamic-programming/)
- [Khan Academy: Dynamic Programming](https://www.khanacademy.org/computing/computer-science/algorithms/dynamic-programming/a/dynamic-programming-overview)
- [MIT OpenCourseWare: Introduction to Dynamic Programming](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/lecture-videos/MIT6_006F11_lec20.pdf)

## 4. Maximum-Flow/Min-Cut and Matching

Maximum-flow/min-cut and matching algorithms are algorithms that find the maximum flow, minimum cut, or maximum matching in a network.

Examples:
- Ford-Fulkerson algorithm
- Edmonds-Karp algorithm
- Dinic's algorithm
- Hopcroft-Karp algorithm

Resources:
- [GeeksforGeeks: Maximum Flow Problem Introduction](https://www.geeksforgeeks.org/max-flow-problem-introduction/)
- [Khan Academy: Maximum Flow and Minimum Cut](https://www.khanacademy.org/computing/computer-science/algorithms/flow-networks/a/maximum-flow-problems)
- [Brilliant: Maximum Flow and Minimum Cut](https://brilliant.org/wiki/maximum-flow-minimum-cut/)

## 5. Linear Programming

Linear programming is a technique for solving optimization problems that involve linear relationships.

Examples:
- Transportation problem
- Diet problem
- Production problem

Resources:
- [GeeksforGeeks: Linear Programming](https://www.geeksforgeeks.org/linear-programming/)
- [Khan Academy: Linear Programming](https://www.khanacademy.org/math/ap-calculus-ab/ab-applications-derivatives/)

Sure, here's the rest of the review sheet in markdown format:

## 6. NP-Completeness

NP-Completeness is a class of decision problems for which no efficient algorithm is currently known. These problems are considered "hard" in the sense that the time required to solve them grows exponentially with the size of the input.

Examples:
- Traveling salesman problem
- Knapsack problem
- Boolean satisfiability problem

Resources:
- [GeeksforGeeks: NP-Completeness](https://www.geeksforgeeks.org/np-completeness-set-1/)
- [Khan Academy: NP-Completeness](https://www.khanacademy.org/computing/computer-science/algorithms/np-completeness/a/np-completeness-introduction)
- [MIT OpenCourseWare: P vs. NP](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-045j-automata-computability-and-complexity-spring-2005/lecture-notes/lec22.pdf)

## 7. Hashing/Sketches

Hashing and sketching are techniques for compressing large datasets or reducing their dimensionality while preserving important information.

Examples:
- Bloom filters
- Count-min sketches

Resources:
- [GeeksforGeeks: Hashing Data Structure](https://www.geeksforgeeks.org/hashing-data-structure/)
- [Khan Academy: Hash Tables](https://www.khanacademy.org/computing/computer-science/algorithms/hash-tables/a/hash-tables)
- [Brilliant: Count-Min Sketches](https://brilliant.org/wiki/count-min-sketch/)
